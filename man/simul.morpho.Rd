% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/morpho.R
\name{simul.morpho}
\alias{simul.morpho}
\title{Simulate a morphological alignment}
\usage{
simul.morpho(tree, mtraits, reps, c = NULL, rho = NULL, R = NULL,
  psample = NULL, method = c("eigen", "chol"), out = NULL, names = NULL,
  ages = NULL, ...)
}
\arguments{
\item{tree}{Phylo, object with a phylogenetic tree
(see \code{\link[ape]{rTraitCont}}).}

\item{mtraits}{Numeric, number of morphological traits to be simulated.}

\item{reps}{Numeric, number of replicates to be simulated.}

\item{c}{(Optional) numeric, population variance to add to the simulated
morphological traits. Requires \code{psample} (see details).}

\item{rho}{(Optional) numeric, correlation value used to generate a
correlation matrix. Requires \code{c}, \code{psample}, and \code{method}
(see details).}

\item{R}{(Optional) matrix, correlation matrix. Requires \code{c},
\code{psample}, and \code{method} (see details).}

\item{psample}{(Optional) numeric, number of individuals to sample
from the simulated population.}

\item{method}{(Optional) character, either \code{"eigen"} or
\code{"col"}, method used to decompose the inverse of the shrunk
correlation matrix. Requires \code{c}, \code{psample}, and either \code{R}
or \code{rho} (see details).}

\item{out}{(Optional) character, name for the output file with the
simulated data in phylip format (see details and \code{\link{write.morpho}}).}

\item{names}{(Optional) list, species name included in the
morphological alignment (see examples in \code{\link{write.morpho}}).}

\item{ages}{(Optional) list, ages of the species included in
the morpholical alignment (see examples in \code{\link{write.morpho}}).}

\item{...}{Further arguments passed to \code{\link[ape]{rTraitCont}}.}
}
\value{
A) If \code{c} nor either \code{rho} or \code{R} are provided, then
a list with a list of each simulated matrix with continuous traits
per replicate is returned:
  \item{M}{  List with \eqn{i} matrices \code{s x p}, with \code{p} simulated continuous
traits for \code{s} specimens}

B) If \code{c} is provided, then a list with a list of the following
matrices, one per replicate, is returned: \eqn{i} simulated matrices
with continuous traits, \eqn{i} noise matrices, \eqn{i}
population matrices, \eqn{i} noisy matrices, and \eqn{i} scaled matrices.
  \item{M}{  List with \eqn{i} matrices \code{s x p}, with \code{p}
  simulated continuous traits for \code{s} specimens}
  \item{N}{  List with \eqn{i} matrices \code{s x p}, with \code{s x p}
  randomly sampled values from a normal distribution with mean 0
  and variance \code{c}}
  \item{P}{  List with \eqn{i} matrices \code{n x p}, where \code{n}
  is the amount of individuals sampled from a population with \code{p}
  continuous traits simulated under a normal distribution
  with mean 0 and variance \code{c}}
  \item{M.n}{  List with \eqn{i} matrices \code{s x p}, result of
  \eqn{\mathrm{M.n_{i}}=\mathrm{M_{i}}+\mathrm{N_{i}}}{M.n_i = M_i + N_i}}
  \item{M.s}{  List with \eqn{i} matrices \code{s x p}, result of
  \eqn{\mathrm{M.s_{i}}=\mathrm{M.n_{i}}\times diag\left(\frac{1}{\sqrt{
  diag(cov(\mathrm{P_{i}}))}}\right)}{
  M.s_i = M.n_i diag( 1 / \sqrt( diag(cov(P_i)) ) )}}

C) If \code{c} and either \code{rho} or \code{R} are provided,
then a list with a list of the following matrices, one per replicate,
is returned: \eqn{i} simulated matrices with continuous traits,
\eqn{i} noise matrices, \eqn{i} population matrices, \eqn{i} noisy
matrices, \eqn{i} scaled matrices, \eqn{i} shrunk correlation matrices,
and \eqn{i} transformed matrices.
  \item{M}{  List with \eqn{i} matrices \code{s x p}, with \code{p}
  simulated continuous traits for \code{s} specimens}
  \item{N}{  List with \eqn{i} matrices \code{s x p}, with \code{s x p}
  randomly sampled values from a normal distribution with mean 0
  and variance \code{c}}
  \item{P}{  List with \eqn{i} matrices \code{n x p}, where \code{n}
  is the amount of individuals sampled from a population with \code{p}
  continuous traits simulated under a normal distribution
  with mean 0 and variance \code{c}}
  \item{M.n}{  List with \eqn{i} matrices \code{s x p}, result of
  \eqn{\mathrm{M.n_{i}}=\mathrm{M_{i}}+\mathrm{N_{i}}}{M.n_i = M_i + N_i}}
  \item{M.s}{  List with \eqn{i} matrices \code{s x p}, result of
  \eqn{\mathrm{M.s_{i}}=\mathrm{M.n_{i}}\times diag\left(\frac{1}{\sqrt{
  diag(cov(\mathrm{P_{i}}))}}\right)}{
  M.s_i = M.n_i diag( 1 / \sqrt( diag(cov(P_i)) ) )}}
  \item{R.sh}{  List with \eqn{i} matrices \code{p x p}, where \code{p}
  is the amount of simulated continuous traits. These matrices are the
  estimated shrunk correlation matrices computed for each replicate
  with the function \code{\link[corpcor]{cov.shrink}}}
  \item{Z}{  List of \eqn{i} matrices \code{s x p}, matrices with the
  transformed data calculated as \eqn{\mathrm{Z_{i}}=\mathrm{M.s_{i}}\times
  \mathrm{A_{i}^{T}}}{Z_i = M.s_i t(A_i)}}
}
\description{
Simulate a continuous morphological alignment using \code{\link[ape]{rTraitCont}}
and later allowing to account for population variance and trait correlation.
}
\details{
The function \code{\link[ape]{rTraitCont}} simulates continuous traits and
can take different parameters to adjust the simulation
(e.g. the model, the rate drift, etc.).
These parameters are the ones the user can pass through
\code{simul.morpho()}.
The default values that \code{simul.morpho()} uses are
\code{model = "BM"}, \code{sigma = 1}, \code{ancestor = F},
and \code{root.value = 0}. Currently, \code{simul.morpho}
supports only \code{ancestor = F}, so do not change this logical
value or the function will not work. See \code{\link[ape]{rTraitCont}}
for more details on this function.

The parameter \code{c} is the population variance. If a correlation
matrix, \code{R}, or the parameter \code{rho} needed to generate
a correlation matrix following the constant correlation model are
not provided, a total of \code{s x p} samples per replicate are
generated following a normal distribution with mean 0
and variance \code{c}, where \code{s} is the number of specimens and
\code{p} the number of morphological traits, \code{mtraits}.
Otherwise, if either \code{R} or \code{rho} are provided, then the
\code{s x p} samples follow a multivariate
normal distribution with mean 0 and variance \code{c R}.
The resulting randomly sampled variables are used to obtain one noise
matrix per replicate \eqn{i}, \code{N_i}, which is added to the
corresponding simulated matrix, \code{M_i}, such as
\eqn{\mathrm{M.n_{i}}=\mathrm{M_{i}}+\mathrm{N_{i}}}{M.n_i = M_i + N_i}.
For each replicate, this results into the noisy matrix \eqn{i},
\code{M.n_i}, which accounts for population noise.

The parameter \code{rho} is used to generate one correlation matrix per
replicate, \code{R_i}, with dimensions \code{p x p}, where \code{p} is
the number of continuous traits, \code{mtraits}. All elements in each
\code{R_i} generated have value \code{rho} (constant correlation model).
If you want to use another correlation matrix, please do not provide
any numeric value to the parameter \code{rho}. Just provide your
preferred correlation matrix as the argument of the parameter \code{R},
class "matrix".

In order to account for population variance, the parameter \code{psample}
is required. This parameter indicates the number of individuals \code{n}
needed to generated one population matrix per replicate, \code{P_i},
with dimensions \code{n x p}, where \code{p} is the number of
continuous traits to be simulated, \code{mtraits}. The simulated
continuous traits for each sampled population per replicate follow a
normal distribution with mean 0 and variance \code{c} (required parameter).
The variance of each \code{P_i} is then calculated and used to scale
the corresponding noisy matrix, \code{M.n_i}, such as
\eqn{\mathrm{M.s_{i}}=\mathrm{M.n_{i}}\times diag\left(\frac{1}{
\sqrt{diag(cov(\mathrm{P_{i}}))}}\right)}{
M.s_i = M.n_i diag( 1 / \sqrt( diag(cov(P_i)) ) )}.

If either the parameter \code{rho} or \code{R} are provided, trait
correlation is considered. Therefore, each scaled simulated matrix with
continuous traits, \code{M.s_i}, needs to be transformed in order
to account for this correlation.
Specifically, \code{simul.morpho} estimates the shrunk correlation
matrix for each replciate, \code{R.sh_i}, with the function
\code{\link[corpcor]{cov.shrink}}. Later, it decomposes the inverse
of \code{R.sh_i} either using the Cholesky decomposition
(if \code{method = "chol"}, see default usage at \code{\link[base]{chol}})
or the eigendecomposition (if \code{method = "eigen"}, see default
usage at \code{\link[base]{eigen}}), such as
\eqn{\mathrm{R.sh_{i}}=\mathrm{A_{i}^{T}}\mathrm{A_{i}}}{R.sh_i = t(A_i) A_i}.
Each matrix \code{t(A_i)} is used to transform the corresponding \code{M.s_i}
such as \eqn{\mathrm{Z_{i}}=\mathrm{M.s_{i}}\times\mathrm{A{i}^{T}}}{Z_i =
M.s_i t(A_i)},
where each matrix \code{Z_i} is the transformed data set, a matrix that
has been scaled and accounts for trait correlation.

If the user wants to output the resulting simulated alignment in
phylip format readable by MCMCTree, then a name for the output file
should be provided as the argument of \code{out}.
}
\examples{
# A) Simulation setup: Simulate a morphological alignment
#    with 'mtraits' = 87 continuous characters that follows a
#    fixed tree, object 'tree', with the default parameters in
#    'simul.morpho' to run 'rTraitCont'.
#    Population variance and correlation are not considered.
#
#    Number of replicates: 2.

     morpho::simul.morpho( tree = tree, mtraits = 87, reps = 2 )


# B) Simulation setup: Simulate a morphological alignment
#    with 'mtraits' = 87 continuous characters that follows a
#    fixed tree, object 'tree', but with different parameters
#    than the default ones in 'simul.morpho' to run
#    'rTraitCont'. Population variance and correlation are not
#    considered.
#
#    Number of replicates: 2.

     morpho::simul.morpho( tree  = tree, mtraits = 87, reps  = 2,
                              model = "OU", root    = 1,  sigma = 0.2,
                              alpha = 2
                             )


# C) Simulation setup: Simulate a morphological alignment
#    with 'mtraits' = 87 continuous characters that follows a
#    fixed tree, object 'tree', with the default parameters in
#    'simul.morpho' to run 'rTraitCont'.
#    Population variance is c = 0.2 and the within population from
#    where to sample has 'psample' = 5 individuals.
#    Correlation is not considered.
#
#    Number of replicates: 2.

     morpho::simul.morpho( tree = tree, mtraits = 87, reps = 2,
                              c    = 0.2,  psample = 5
                             )


# D) Simulation setup: Simulate a morphological alignment
#    with 'mtraits' = 87 continuous characters that follows a
#    fixed tree, object 'tree', with the default parameters in
#    'simul.morpho' to run 'rTraitCont'.
#    Population variance is c = 0.2 and the within population from
#    where to sample has 'psample' = 5 individuals.
#    A correlation matrix is provided, so once it is shrunk, it can
#    be decomposed using the Cholesky decomposition method.
#
#    Number of replicates: 2.


     morpho::simul.morpho( tree   = tree, mtraits = 87, reps = 2,
                              c      = 0.2,  psample = 5,  R    = R,
                              method = "chol"
                             )


# E) Simulation setup: Simulate a morphological alignment
#    with 'mtraits' = 87 continuous characters that follows a
#    fixed tree, object 'tree', with the default parameters in
#    'simul.morpho' to run 'rTraitCont'.
#    Population variance is c = 0.2 and the within population from
#    where to sample has 'psample' = 5 individuals.
#    A correlation matrix is provided, so once it is shrunk, it can
#    be decomposed using the eigen decomposition method.
#
#    Number of replicates: 2.

     morpho::simul.morpho( tree   = tree, mtraits = 87, reps = 2,
                              c      = 0.2,  psample = 5,  R    = R,
                              method = "eigen"
                             )


# F) Simulation setup: Simulate a morphological alignment
#    with 'mtraits' = 87 continuous characters that follows a
#    fixed tree, object 'tree', with the default parameters in
#    'simul.morpho' to run 'rTraitCont'.
#    Population variance is c = 0.2 and the within population from
#    where to sample has 'psample' = 5 individuals.
#    The rho parameter, 'rho' = 0.5, is provided so a correlation
#    matrix following the constant correlation model is generated, which
#    later will be shrunk. The shrunk matrix will be decomposed
#    using the shrunk correlation matrix.
#
#    Number of replicates: 2.

     morpho::simul.morpho( tree   = tree, mtraits = 87, reps = 2,
                              c      = 0.2,  psample = 5,  rho  = 0.5,
                              method = "chol"
                             )


# G) Simulation setup: Simulate a morphological alignment
#    with 'mtraits' = 87 continuous characters that follows a
#    fixed tree, object 'tree', with the default parameters in
#    'simul.morpho' to run 'rTraitCont'.
#    Population variance is c = 0.2 and the within population from
#    where to sample has 'psample' = 5 individuals.
#    The rho parameter, 'rho' = 0.5, is provided so a correlation
#    matrix following the constant correlation model is generated, which
#    later will be shrunk. The shrunk matrix will be decomposed
#    using the shrunk correlation matrix.
#    Set specific names and ages for the simulated species. The order
#    follows the order in object 'tree'.
#
#    Number of replicates: 2.


     names <- list( sp1  = "A", sp2  = "B", sp3  = "F", sp4  = "C",
                    sp5  = "H", sp6  = "D", sp7  = "G", sp8  = "E"
                   )

     ages <- list( sp1 = 0,   sp2 = 0, sp3 = 0.1, sp4 = 0,
                   sp5 = 0.7, sp6 = 0, sp7 = 0.3, sp8 = 0
                  )

     morpho::simul.morpho( tree   = tree,   mtraits = 87,   reps = 2,
                              c      = 0.2,    psample = 5,    rho  = 0.5,
                              method = "chol", names   = names,
                              ages   = ages
                             )

}
\seealso{
\code{\link{write.morpho}}
}
\author{
Sandra Alvarez-Carretero
}
